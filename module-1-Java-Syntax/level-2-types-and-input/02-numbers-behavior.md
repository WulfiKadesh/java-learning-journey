# 4 неожиданных факта о числах в Java

Помню, как в начале обучения сталкивался с ситуацией: код выглядит абсолютно логичным, а результат вычислений — совсем не тот, что ожидаешь. Оказывается, проблема была в базовых правилах работы Java с числами.

Со временем я понял, что операции с целыми и дробными числами подчиняются строгим, но не всегда очевидным законам. Эти «подводные камни» могут приводить к трудноуловимым багам там, где, казалось бы, все должно работать идеально.

Хочу поделиться четырьмя открытиями о числах в Java, которые перевернули мое представление о, казалось бы, простых вещах.

## Первое открытие: загадочное деление 5 / 2

Помню свое удивление, когда написал `double d = 5 / 2;` и ожидал увидеть 2.5, а получил 2.0. Оказалось, когда в операции деления участвуют два целых числа, Java выполняет целочисленное деление — результат будет целым числом, а дробная часть просто отбрасывается.

Самое важное, что я тогда не понимал: Java-машина сначала вычисляет значение выражения `5 / 2`, получает 2, и только потом присваивает этот результат переменной d. Даже то, что переменная d имеет тип double, не влияет на саму операцию — к моменту присваивания значение уже "испорчено".

Решение оказалось простым: нужно, чтобы хотя бы одно число в операции было вещественным. Достаточно добавить `.0`: `5.0 / 2`, `5 / 2.0` или `5.0 / 2.0` — и Java поймет, что нужно выполнить деление для вещественных чисел.

## Второе откровение: округление, которого нет

Еще одна ситуация, которая меня удивила — приведение double к int. Я ожидал, что `(int)5.999` округлится до 6 по математическим правилам, но нет. При преобразовании double к int дробная часть не округляется, а полностью отбрасывается. Технически это называется усечением (truncation).

```java
double a = 5.999;
int x = (int)(a); // x будет равен 5, а не 6
```

Это становится особенно наглядно в выражениях:
```java
double a = 5.999;
int b = 2;
// Сначала вычисляется a * b = 11.998
// Затем при преобразовании в int дробная часть отбрасывается
int x = (int)(a * b); // x будет равен 11, а не 12
```
## Третий секрет: как заставить переменные делиться правильно

Разобравшись с числами 5 и 2, я столкнулся с более сложной задачей: как поделить две переменные типа int и получить точный дробный результат?
```java
int a = 5;
int b = 2;
double d = a / b; // d все равно будет 2.0
```

Как мы уже знаем, выражение `a / b` вычисляется по правилам целочисленного деления, и переменная d получает уже готовый, усеченный результат.

Решение оказалось элегантным — нужно заставить Java преобразовать одну из переменных в double прямо перед делением. Самый простой способ — умножить ее на вещественную единицу 1.0:
```java
int a = 5;
int b = 2;
double d = a * 1.0 / b; // d будет равно 2.5
```
Здесь крайне важен порядок операций. Выражение `a * 1.0 / b` сработает правильно, а вот `a / b * 1.0` — нет. Во втором случае сначала произойдет целочисленное деление 5 / 2 (результат 2), и только потом умножение на 1.0, что даст 2.0.
## Четвертое прозрение: невидимая магия преобразований

Последнее открытие касается автоматического повышения типов. Оказалось, если в одной операции участвуют целое и вещественное число, Java автоматически преобразует целое число в вещественное перед вычислением.

Именно этот механизм и есть та самая «магия», которая заставляет работать наш трюк с `* 1.0`. Умножая a на 1.0, мы создаем смешанное выражение (int и double), заставляя Java преобразовать a в double до начала деления.

Например, в выражении `5 * 2.0` Java не будет пытаться умножить int на double. Вместо этого она сначала «повысит» тип числа 5 до 5.0 и выполнит операцию `5.0 * 2.0`. В результате получается 10.0 (тип double), а не 10 (тип int).

## Послесловие

Эти четыре принципа — целочисленное деление, усечение при приведении типов, трюк с 1.0 и автоматическое повышение — перестали для меня быть просто теорией. Теперь, работая с числами, я вижу не просто код, а те процессы, которые происходят «под капотом».

Как оказалось, даже в самых простых операциях могут скрываться интересные открытия, которые меняют взгляд на программирование в целом.
